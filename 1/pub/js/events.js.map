{"version":3,"sources":["events.ts"],"names":[],"mappings":"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","file":"events.js","sourcesContent":["////////////////////////////////////////////////////////////////\r\n///\r\n///   This is a simple event manager. you can subscribe to\r\n///   events by calling the subscribe function and passing\r\n///   in a path which is a . delimited namespace for the\r\n///   event. Events that then publish anything below that\r\n///   namespace will get passed to the function.\r\n///\r\n////////////////////////////////////////////////////////////////\r\n\r\n/** Represents an event subscription. */\r\ninterface Subscription {\r\n    id: number;\r\n    names: string[];\r\n    callback: (data: any, event?: string) => (any | void);\r\n}\r\n\r\nclass EventManager {\r\n    currentId = 0;\r\n    subscriptions: { [id: number]: Subscription } = { };\r\n    namespaces: { [name: string]: Subscription[] } = { };\r\n\r\n    private iterateOverEventName(name: string, callback:(namespace: string) => void) {\r\n        let namespaces = name.split(\".\");\r\n        let nameAcc = \"\";\r\n        for (let name of namespaces) {\r\n            if (nameAcc.length != 0) {\r\n                nameAcc = nameAcc + \".\"\r\n            }\r\n            nameAcc = nameAcc + name;\r\n            callback(nameAcc);\r\n        }\r\n    }\r\n\r\n    /** Subscribe to a given event. Note that your event will get called for any\r\n        published event and down the chain.\r\n\r\n        eg. Subscribe(\"foo.bar\", fun...) will be called with Publish(\"foo.bar.bas\") */\r\n    Subscribe(name: string, callback: (data: any, eventName?: string) => (any | void)) {\r\n        return this.SubscribeMultiple([name], callback);\r\n    }\r\n\r\n    /** Allows you to subscribe to multiple different events with one handler.\r\n        This event will get called for any of the passed in events. */\r\n    SubscribeMultiple(names: string[], callback: (data: any, eventName?: string) => (any | void)) {\r\n        let sub: Subscription = {id: this.currentId, names: names, callback: callback}\r\n        this.subscriptions[this.currentId] = sub;\r\n        this.currentId++;\r\n\r\n        for (let name of names) {\r\n            if (!(name in this.namespaces)) {\r\n                this.namespaces[name] = [];\r\n            }\r\n            this.namespaces[name].push(sub);\r\n        }\r\n\r\n        return sub.id;\r\n    }\r\n\r\n    /** Stops this event handler from being called. Used to free memory generally. */\r\n    Unsubscribe(id: number) {\r\n        let sub = this.subscriptions[id];\r\n        delete this.subscriptions[id];\r\n        for (let name in sub.names) {\r\n            this.namespaces[name] = this.namespaces[name].filter(s => s != sub);\r\n        }\r\n    }\r\n\r\n    /** Publish the event with name: name and data: data. */\r\n    async Publish<T>(name: string, data?: T): Promise<any[]> {\r\n        return await this.PublishMultiple([name], data);\r\n    }\r\n\r\n    /** Publish multiple events with a given argument. The idea here is that if\r\n        an event subscribed to multiple event names it will only get called once. */\r\n    async PublishMultiple<T>(names: string[], data?: T): Promise<any[]> {\r\n        let calledEvents: Subscription[] = [];\r\n        let results: Promise<any>[] = [];\r\n        for (let name of names) {\r\n            this.iterateOverEventName(name, (partialName) => {\r\n                if (Array.isArray(this.namespaces[partialName])) {\r\n                    for (let sub of this.namespaces[partialName]) {\r\n                        if (!(calledEvents.some(s => s === sub))) {\r\n                            let result = sub.callback(data, name);\r\n                            if (result != undefined) {\r\n                                results.push(Promise.resolve(result));\r\n                            }\r\n                            calledEvents.push(sub);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (results.length != 0) {\r\n            return Promise.all(results);\r\n        } else {\r\n            return Promise.resolve([]);\r\n        }\r\n    }\r\n}\r\n\r\nexport default new EventManager();\r\n"]}