{"version":3,"sources":["collisionManager.ts"],"names":[],"mappings":"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","file":"collisionManager.js","sourcesContent":["import * as ces from \"./ces\";\r\nimport {Update} from \"./animationManager\";\r\n\r\nimport {Entity as RenderableEntity} from \"./webglManager\";\r\nimport {EventManager3} from \"./eventManager\";\r\n\r\nimport {CombinedEntity} from \"./entity\";\r\n\r\nimport * as utils from \"./utils\";\r\n\r\ninterface Circle {\r\n  kind: \"circle\"\r\n}\r\n\r\ninterface Rectangle {\r\n  kind: \"rectangle\"\r\n}\r\n\r\ninterface Poly {\r\n  kind: \"polygon\"\r\n  points: utils.Polygon\r\n}\r\n\r\ninterface CompoundPoly {\r\n  kind: \"compound polygon\"\r\n  children: utils.Polygon[]\r\n}\r\n\r\nconst obj: any = {};\r\n\r\nexport interface GeometryEntity extends RenderableEntity {\r\n  collisionShape?: Circle | Rectangle | Poly | CompoundPoly;\r\n}\r\n\r\nexport interface Entity extends GeometryEntity {\r\n  collidable: boolean;\r\n}\r\nexport function isCollidable(entity: CombinedEntity): entity is Entity { return \"collidable\" in entity; }\r\n\r\n// Algorithm modified from http://wiki.roblox.com/index.php?title=2D_Collision_Detection\r\nexport function getCorners(entity: GeometryEntity) : utils.Polygon[]{\r\n  let scale = entity.scale || 1;\r\n  let rotation = entity.rotation || 0;\r\n  let center = entity.center || {x: 0.5, y: 0.5};\r\n  let corners: utils.Polygon[] = [];\r\n  if (entity.collisionShape == null || entity.collisionShape.kind === \"rectangle\") {\r\n    let left = entity.position.x + entity.dimensions.width * center.x;\r\n    let right = entity.position.x - entity.dimensions.width * (1 - center.x);\r\n    let bottom = entity.position.y + entity.dimensions.height * center.y;\r\n    let top = entity.position.y - entity.dimensions.height * (1 - center.x);\r\n\r\n    corners.push([\r\n      [left, top],\r\n      [right, top],\r\n      [right, bottom],\r\n      [left, bottom]\r\n    ]);\r\n  } else if (entity.collisionShape.kind === \"polygon\") {\r\n    corners = [entity.collisionShape.points];\r\n  } else if (entity.collisionShape.kind === \"compound polygon\"){\r\n    for (let child of entity.collisionShape.children) {\r\n      corners.push(child);\r\n    }\r\n  }\r\n  let retList: utils.Polygon[] = [];\r\n  for (let cornersList of corners) {\r\n    retList.push(utils.transformPoly(cornersList, entity.position, rotation, scale));\r\n  }\r\n  return retList;\r\n}\r\n\r\nfunction getAxis(entity: Entity) {\r\n  if (entity.collisionShape == null || entity.collisionShape.kind != \"circle\") {\r\n    let axis: utils.Vec[] = [];\r\n    let childCorners = getCorners(entity);\r\n    for (let child of childCorners) {\r\n      let previous = child[child.length - 1];\r\n      for (let corner of child) {\r\n        axis.push(utils.normal(utils.unit(utils.sub(corner, previous))));\r\n        previous = corner;\r\n      }\r\n    }\r\n    return axis;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction projectedBounds(entity: Entity, axis: utils.Vec) {\r\n  if (entity.collisionShape != null && entity.collisionShape.kind === \"circle\") {\r\n    let scale = ((entity || obj).renderer || obj).scale || 1;\r\n    let center = utils.dot([entity.position.x, entity.position.y], axis);\r\n    let radius = Math.max(entity.dimensions.width * scale, entity.dimensions.height * scale) / 2;\r\n    return {max: center + radius, min: center - radius};\r\n  } else {\r\n    let corners = getCorners(entity);\r\n    let min = utils.dot(corners[0][0], axis);\r\n    let max = min;\r\n    for (let child of corners) {\r\n      for (let corner of child) {\r\n        let projectedCorner = utils.dot(corner, axis);\r\n        if (projectedCorner > max) max = projectedCorner;\r\n        if (projectedCorner < min) min = projectedCorner;\r\n      }\r\n    }\r\n    return {min: min, max: max};\r\n  }\r\n}\r\n\r\nfunction calculateOverlap(e1: Entity, e2: Entity, axis: utils.Vec) {\r\n  let b1 = projectedBounds(e1, axis);\r\n  let b2 = projectedBounds(e2, axis);\r\n  if (b2.min > b1.max || b2.max < b1.min) {\r\n    return null;\r\n  }\r\n  return b1.max > b2.max ? -(b2.max - b1.min) : (b1.max - b2.min);\r\n}\r\n\r\nfunction getOverlap(e1: Entity, e2: Entity) {\r\n  let c1 = getCorners(e1);\r\n  let c2 = getCorners(e2)\r\n  let result: {depth: number, normal: utils.Vec} = null;\r\n  let normal: utils.Vec = [];\r\n  for (let axis of getAxis(e1).concat(getAxis(e2))) {\r\n    let overlap = calculateOverlap(e1, e2, axis);\r\n    if (overlap == null) return null;\r\n\r\n    if (result == null || Math.abs(overlap) < result.depth) {\r\n      if (overlap < 0) {\r\n        result = {\r\n          depth: -overlap,\r\n          normal: utils.scale(axis, -1)\r\n        }\r\n      } else {\r\n        result = {\r\n          depth: overlap,\r\n          normal: axis\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport let Collision = new EventManager3<Entity, Entity, {depth: number, normal: utils.Vec}>();\r\n\r\nexport function setup() {\r\n  Update.Subscribe(() => {\r\n    let collidables = ces.getEntities(isCollidable);\r\n\r\n    for (let collider of collidables) {\r\n      for (let collidable of collidables) {\r\n        if (collidable !== collider) {\r\n          let result = getOverlap(collider, collidable);\r\n          if (result !== null) {\r\n            Collision.Publish(collider, collidable, result);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n"]}