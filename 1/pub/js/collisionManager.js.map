{"version":3,"sources":["collisionManager.ts"],"names":[],"mappings":"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","file":"collisionManager.js","sourcesContent":["import * as ces from \"./ces\";\r\nimport {Update} from \"./animationManager\";\r\nimport utils from \"./utils\";\r\n\r\nimport {Dimensions, Position} from \"./pixiManager\"\r\nimport {EventManager3} from \"./eventManager\";\r\n\r\nimport {CombinedEntity} from \"./entity\";\r\n\r\ninterface Circle {\r\n    kind: \"circle\"\r\n}\r\n\r\ninterface Rectangle {\r\n    kind: \"rectangle\"\r\n}\r\n\r\ninterface Polygon {\r\n    kind: \"polygon\"\r\n    points: number[][]\r\n}\r\n\r\nexport interface Entity {\r\n    collidable?: boolean;\r\n    position: Position;\r\n    dimensions: Dimensions;\r\n    renderer?: {\r\n        scale: number;\r\n    };\r\n    collisionShape?: Circle | Rectangle | Polygon;\r\n}\r\nexport function isCollidable(entity: CombinedEntity): entity is Entity { return \"collidable\" in entity; }\r\n\r\n// Algorithm modified from http://wiki.roblox.com/index.php?title=2D_Collision_Detection\r\nfunction getNormal(vec: number[]) {\r\n    return [vec[1], -vec[0]];\r\n}\r\n\r\nfunction subVec(vec1: number[], vec2: number[]) {\r\n    let retVec = [];\r\n    for (let i = 0; i < vec1.length; i++) {\r\n        retVec[i] = vec1[i] - vec2[i];\r\n    }\r\n    return retVec;\r\n}\r\n\r\nfunction dotVec(vec1: number[], vec2: number[]) {\r\n    let retVal = 0;\r\n    for (let i = 0; i < vec1.length; i++) {\r\n        retVal += vec1[i] * vec2[i];\r\n    }\r\n    return retVal;\r\n}\r\n\r\nfunction vecLength(vec: number[]) {\r\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\r\n}\r\n\r\nfunction unitVec(vec: number[]) {\r\n    let length = vecLength(vec);\r\n    return [\r\n        vec[0] / length,\r\n        vec[1] / length\r\n    ];\r\n}\r\n\r\nfunction rotateAndTranslate(entity: Entity, relativePoint: number[]) {\r\n    let center = [entity.position.x, entity.position.y];\r\n    let rotation = 0;\r\n    let scale = utils.defaultValue(() => entity.renderer.scale, 1);\r\n    if (\"rotation\" in entity.position) {\r\n        rotation = entity.position.rotation;\r\n    }\r\n\r\n    let newX = center[0] + (relativePoint[0] * scale - center[0]) * Math.cos(rotation) - (relativePoint[1] * scale - center[1]) * Math.sin(rotation);\r\n    let newY = center[1] + (relativePoint[0] * scale - center[0]) * Math.sin(rotation) + (relativePoint[1] * scale - center[1]) * Math.cos(rotation);\r\n    relativePoint[0] = newX;\r\n    relativePoint[1] = newY;\r\n}\r\n\r\nfunction getCorners(entity: Entity) {\r\n    if (entity.collisionShape == null || entity.collisionShape.kind === \"rectangle\") {\r\n        let scale = utils.defaultValue(() => entity.renderer.scale, 1);\r\n        let left = entity.position.x + entity.dimensions.width * entity.position.cx * scale;\r\n        let right = entity.position.x - entity.dimensions.width * (1 - entity.position.cx) * scale;\r\n        let bottom = entity.position.y + entity.dimensions.height * entity.position.cy * scale;\r\n        let top = entity.position.y - entity.dimensions.height * (1 - entity.position.cy) * scale;\r\n\r\n        let corners = [\r\n            [left, top],\r\n            [right, top],\r\n            [right, bottom],\r\n            [left, bottom]\r\n        ];\r\n\r\n        for (let corner of corners) {\r\n            rotateAndTranslate(entity, corner);\r\n        }\r\n        return corners;\r\n    } else if (entity.collisionShape.kind === \"polygon\") {\r\n        let corners = entity.collisionShape.points;\r\n        for (let corner of corners) {\r\n            rotateAndTranslate(entity, corner);\r\n        }\r\n    } else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction getAxis(entity: Entity) {\r\n    if (entity.collisionShape == null || entity.collisionShape.kind != \"circle\") {\r\n        let corners = getCorners(entity);\r\n        return [\r\n            getNormal(unitVec(subVec(corners[0], corners[1]))),\r\n            getNormal(unitVec(subVec(corners[0], corners[3])))\r\n        ];\r\n    } else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction projectedBounds(entity: Entity, axis: number[]) {\r\n    if (entity.collisionShape != null && entity.collisionShape.kind === \"circle\") {\r\n        let scale = utils.defaultValue(() => entity.renderer.scale, 1);\r\n        let center = dotVec([entity.position.x, entity.position.y], axis);\r\n        let radius = Math.max(entity.dimensions.width * scale, entity.dimensions.height * scale) / 2;\r\n        return {max: center + radius, min: center - radius};\r\n    } else {\r\n        let corners = getCorners(entity);\r\n        let min = dotVec(corners[0], axis);\r\n        let max = min;\r\n        for (let i = 1; i < corners.length; i++) {\r\n            let corner = corners[i];\r\n            let projectedCorner = dotVec(corner, axis);\r\n            if (projectedCorner > max) max = projectedCorner;\r\n            if (projectedCorner < min) min = projectedCorner;\r\n        }\r\n        return {min: min, max: max};\r\n    }\r\n}\r\n\r\nfunction calculateOverlap(e1: Entity, e2: Entity, axis: number[]) {\r\n    let b1 = projectedBounds(e1, axis);\r\n    let b2 = projectedBounds(e2, axis);\r\n    if (b2.min > b1.max || b2.max < b1.min) {\r\n        return null;\r\n    }\r\n    return b1.max > b2.max ? -(b2.max - b1.min) : (b1.max - b2.min);\r\n}\r\n\r\nfunction getOverlap(e1: Entity, e2: Entity) {\r\n    let c1 = getCorners(e1);\r\n    let c2 = getCorners(e2);\r\n    let result: {depth: number, normal: number[]} = null;\r\n    let normal: number[] = [];\r\n    for (let axis of getAxis(e1).concat(getAxis(e2))) {\r\n        let overlap = calculateOverlap(e1, e2, axis);\r\n        if (overlap == null) return null;\r\n\r\n        if (result == null || Math.abs(overlap) < result.depth) {\r\n            if (overlap < 0) {\r\n                result = {\r\n                    depth: -overlap,\r\n                    normal: [\r\n                        -axis[0],\r\n                        -axis[1]\r\n                    ]\r\n                }\r\n            } else {\r\n                result = {\r\n                    depth: overlap,\r\n                    normal: axis\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport let Collision = new EventManager3<Entity, Entity, {depth: number, normal: number[]}>();\r\n\r\nexport function Setup() {\r\n    Update.Subscribe(() => {\r\n        let collidables = ces.GetEntities(isCollidable);\r\n        for (let collider of collidables) {\r\n            for (let collidable of collidables) {\r\n                if (collidable !== collider) {\r\n                    let result = getOverlap(collider, collidable);\r\n                    if (result !== null) {\r\n                        Collision.Publish(collider, collidable, result);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n"]}