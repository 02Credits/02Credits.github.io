{"version":3,"sources":["collisionManager.ts"],"names":[],"mappings":"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","file":"collisionManager.js","sourcesContent":["import * as pixi from \"pixi.js\";\r\n\r\nimport * as ces from \"./ces\";\r\nimport {Update} from \"./animationManager\";\r\n\r\nimport {Dimensions, Position, overlay} from \"./pixiManager\"\r\nimport {EventManager3} from \"./eventManager\";\r\n\r\nimport {CombinedEntity} from \"./entity\";\r\n\r\nimport * as geometryUtils from \"./geometryUtils\";\r\n\r\ninterface Circle {\r\n  kind: \"circle\"\r\n}\r\n\r\ninterface Rectangle {\r\n  kind: \"rectangle\"\r\n}\r\n\r\ninterface Poly {\r\n  kind: \"polygon\"\r\n  points: geometryUtils.Polygon\r\n}\r\n\r\ninterface CompoundPoly {\r\n  kind: \"compound polygon\"\r\n  children: geometryUtils.Polygon[]\r\n}\r\n\r\nconst obj: any = {};\r\n\r\nexport interface GeometryEntity {\r\n  position: Position;\r\n  dimensions: Dimensions;\r\n  renderer?: {\r\n    scale: number;\r\n  };\r\n  collisionShape?: Circle | Rectangle | Poly | CompoundPoly;\r\n}\r\n\r\nexport interface Entity extends GeometryEntity {\r\n  collidable: boolean;\r\n}\r\nexport function isCollidable(entity: CombinedEntity): entity is Entity { return \"collidable\" in entity; }\r\n\r\n// Algorithm modified from http://wiki.roblox.com/index.php?title=2D_Collision_Detection\r\nexport function getCorners(entity: GeometryEntity) : geometryUtils.Polygon[]{\r\n  let scale = (entity.renderer || obj).scale || 1;\r\n  let rotation = entity.position.rotation || 0;\r\n  let position = [entity.position.x, entity.position.y];\r\n  let corners: geometryUtils.Polygon[] = [];\r\n  if (entity.collisionShape == null || entity.collisionShape.kind === \"rectangle\") {\r\n    let left = entity.position.x + entity.dimensions.width * entity.position.cx;\r\n    let right = entity.position.x - entity.dimensions.width * (1 - entity.position.cx);\r\n    let bottom = entity.position.y + entity.dimensions.height * entity.position.cy;\r\n    let top = entity.position.y - entity.dimensions.height * (1 - entity.position.cy);\r\n\r\n    corners.push([\r\n      [left, top],\r\n      [right, top],\r\n      [right, bottom],\r\n      [left, bottom]\r\n    ]);\r\n  } else if (entity.collisionShape.kind === \"polygon\") {\r\n    corners = [entity.collisionShape.points];\r\n  } else if (entity.collisionShape.kind === \"compound polygon\"){\r\n    for (let child of entity.collisionShape.children) {\r\n      corners.push(child);\r\n    }\r\n  }\r\n  let retList: geometryUtils.Polygon[] = [];\r\n  for (let cornersList of corners) {\r\n    retList.push(geometryUtils.transformPoly(cornersList, position, rotation, scale));\r\n  }\r\n  return retList;\r\n}\r\n\r\nfunction getAxis(entity: Entity) {\r\n  if (entity.collisionShape == null || entity.collisionShape.kind != \"circle\") {\r\n    let axis: geometryUtils.Vec[] = [];\r\n    let childCorners = getCorners(entity);\r\n    for (let child of childCorners) {\r\n      let previous = child[child.length - 1];\r\n      for (let corner of child) {\r\n        axis.push(geometryUtils.normal(geometryUtils.unit(geometryUtils.sub(corner, previous))));\r\n        previous = corner;\r\n      }\r\n    }\r\n    return axis;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\nfunction projectedBounds(entity: Entity, axis: geometryUtils.Vec) {\r\n  if (entity.collisionShape != null && entity.collisionShape.kind === \"circle\") {\r\n    let scale = ((entity || obj).renderer || obj).scale || 1;\r\n    let center = geometryUtils.dot([entity.position.x, entity.position.y], axis);\r\n    let radius = Math.max(entity.dimensions.width * scale, entity.dimensions.height * scale) / 2;\r\n    return {max: center + radius, min: center - radius};\r\n  } else {\r\n    let corners = getCorners(entity);\r\n    let min = geometryUtils.dot(corners[0][0], axis);\r\n    let max = min;\r\n    for (let child of corners) {\r\n      for (let corner of child) {\r\n        let projectedCorner = geometryUtils.dot(corner, axis);\r\n        if (projectedCorner > max) max = projectedCorner;\r\n        if (projectedCorner < min) min = projectedCorner;\r\n      }\r\n    }\r\n    return {min: min, max: max};\r\n  }\r\n}\r\n\r\nfunction calculateOverlap(e1: Entity, e2: Entity, axis: geometryUtils.Vec) {\r\n  let b1 = projectedBounds(e1, axis);\r\n  let b2 = projectedBounds(e2, axis);\r\n  if (b2.min > b1.max || b2.max < b1.min) {\r\n    return null;\r\n  }\r\n  return b1.max > b2.max ? -(b2.max - b1.min) : (b1.max - b2.min);\r\n}\r\n\r\nfunction getOverlap(e1: Entity, e2: Entity) {\r\n  let c1 = getCorners(e1);\r\n  let c2 = getCorners(e2);\r\n  let result: {depth: number, normal: geometryUtils.Vec} = null;\r\n  let normal: geometryUtils.Vec = [];\r\n  for (let axis of getAxis(e1).concat(getAxis(e2))) {\r\n    let overlap = calculateOverlap(e1, e2, axis);\r\n    if (overlap == null) return null;\r\n\r\n    if (result == null || Math.abs(overlap) < result.depth) {\r\n      if (overlap < 0) {\r\n        result = {\r\n          depth: -overlap,\r\n          normal: [\r\n              -axis[0],\r\n              -axis[1]\r\n          ]\r\n        }\r\n      } else {\r\n        result = {\r\n          depth: overlap,\r\n          normal: axis\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport let Collision = new EventManager3<Entity, Entity, {depth: number, normal: geometryUtils.Vec}>();\r\n\r\nexport function Setup() {\r\n  let physicsOverlay = new pixi.Graphics();\r\n  // overlay.addChild(physicsOverlay);\r\n  Update.Subscribe(() => {\r\n    let collidables = ces.GetEntities(isCollidable);\r\n\r\n    physicsOverlay.clear();\r\n    for (let collider of collidables) {\r\n      if (!collider.collisionShape || collider.collisionShape.kind !== \"circle\") {\r\n        let corners = getCorners(collider);\r\n        physicsOverlay.lineStyle(0.1, 0xFF0000, 1);\r\n        for (let poly of corners) {\r\n          let startCorner = poly[poly.length - 1];\r\n          physicsOverlay.beginFill(0xFF0000, 0.5);\r\n          physicsOverlay.moveTo(startCorner[0], startCorner[1]);\r\n          for (let corner of poly) {\r\n            physicsOverlay.lineTo(corner[0], corner[1]);\r\n          }\r\n          physicsOverlay.endFill();\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let collider of collidables) {\r\n      for (let collidable of collidables) {\r\n        if (collidable !== collider) {\r\n          let result = getOverlap(collider, collidable);\r\n          if (result !== null) {\r\n            Collision.Publish(collider, collidable, result);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n"]}