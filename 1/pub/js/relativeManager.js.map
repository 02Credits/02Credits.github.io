{"version":3,"sources":["relativeManager.ts"],"names":[],"mappings":";;;IAIA,cAAwB,MAAS;QAC/B,IAAI,GAAG,GAAG,MAAa,CAAC;QACxB,IAAI,OAAO,GAAG,GAAU,CAAC;QACzB,GAAG,CAAC,CAAC,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;YACpB,IAAI,QAAQ,GAAG,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YAC/B,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC;gBACzB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAa;oBAC3B,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACT,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;oBAClB,CAAC;oBACD,IAAI,MAAM,GAAW,GAAG,CAAC,GAAG,CAAC,CAAC;oBAC9B,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC;oBACvB,EAAE,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC;wBAClB,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;oBACD,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC;oBACvB,EAAE,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC;wBAClB,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;oBACD,IAAI,OAAO,GAAG,GAAG,GAAG,GAAG,CAAC;oBACxB,EAAE,CAAC,CAAC,OAAO,IAAI,GAAG,CAAC,CAAC,CAAC;wBACnB,MAAM,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;oBACzB,CAAC;oBACD,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC;oBACvB,EAAE,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC;wBAClB,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;oBACD,MAAM,CAAC,MAAM,CAAC;gBAChB,CAAC,CAAA;YACH,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC;gBAChC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAa;oBAC3B,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACT,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;oBAClB,CAAC;oBACD,IAAI,MAAM,GAAW,GAAG,CAAC,GAAG,CAAC,CAAC;oBAC9B,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC;oBACvB,EAAE,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC;wBAClB,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;oBACxB,CAAC;oBACD,MAAM,CAAC,MAAM,CAAC;gBAChB,CAAC,CAAA;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;gBACjC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAU;oBACxB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACT,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;oBAClB,CAAC;oBACD,MAAM,CAAC,WAAW,CAAC;gBACrB,CAAC,CAAA;YACH,CAAC;QACH,CAAC;QACD,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC;QACrB,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;;;;;QACD,CAAC","file":"relativeManager.js","sourcesContent":["export type Wrapped<T> = { unwrap: T } | {\r\n  [P in keyof T]: (val?: T[P]) => Wrapped<T[P]>\r\n}\r\n\r\nexport function wrap<T>(source: T): Wrapped<T> {\r\n  let obj = source as any;\r\n  let wrapped = obj as any;\r\n  for (let key in obj) {\r\n    let propType = typeof obj[key];\r\n    if (propType == \"number\") {\r\n      wrapped[key] = (prop?: number) => {\r\n        if (prop) {\r\n          obj[key] = prop;\r\n        }\r\n        let result: number = obj[key];\r\n        let sumKey = \"+\" + key;\r\n        if (sumKey in obj) {\r\n          result += obj[sumKey];\r\n        }\r\n        let subKey = \"-\" + key;\r\n        if (subKey in obj) {\r\n          result -= obj[subKey];\r\n        }\r\n        let prodKey = \"*\" + key;\r\n        if (prodKey in obj) {\r\n          result *= obj[prodKey];\r\n        }\r\n        let divKey = \"/\" + key;\r\n        if (divKey in obj) {\r\n          result /= obj[divKey];\r\n        }\r\n        return result;\r\n      }\r\n    } else if (propType == \"string\") {\r\n      wrapped[key] = (prop?: string) => {\r\n        if (prop) {\r\n          obj[key] = prop;\r\n        }\r\n        let result: string = obj[key];\r\n        let sumKey = \"+\" + key;\r\n        if (sumKey in obj) {\r\n          result += obj[sumKey];\r\n        }\r\n        return result;\r\n      }\r\n    } else {\r\n      let wrappedProp = wrap(obj[key]);\r\n      wrapped[key] = (prop?: any) => {\r\n        if (prop) {\r\n          obj[key] = prop;\r\n        }\r\n        return wrappedProp;\r\n      }\r\n    }\r\n  }\r\n  wrapped.unwrap = obj;\r\n  return wrapped;\r\n}\r\n"]}